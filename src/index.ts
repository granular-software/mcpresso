import express from 'express';
import cors from 'cors';
import { z } from 'zod';
import { zodToJsonSchema } from 'zod-to-json-schema';
import { McpServer, ResourceTemplate } from '@modelcontextprotocol/sdk/server/mcp.js';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js';
import type { Express, Request, Response } from 'express';
import type { CallToolResult, ReadResourceResult } from '@modelcontextprotocol/sdk/types.js';
import { type AuthConfig, createAuthMiddleware } from './auth.js';

// --- Core Method and Resource Configuration ---

/** Represents a relationship to another resource type. */
interface Relation {
  /** The name of the resource type being referenced. */
  type: string;
}

/**
 * The fully processed configuration for a single resource tool/method.
 * This is generated by the `createResource` function.
 * @internal
 */
interface Method {
  description: string;
  inputSchema: z.ZodObject<any, any, any>;
  outputSchema: z.ZodTypeAny;
  handler: (args: any) => Promise<any>;
  // A flag to indicate if the output should be enriched with URIs.
  returnsResourceList?: boolean;
}

/**
 * A user-defined method. The `createResource` factory uses this to build
 * the final `Method` configuration.
 */
export type MethodDefinition<
  TInput extends z.ZodObject<any, any, any> | z.ZodTypeAny,
  TOutput,
> = {
  description?: string;
  inputSchema?: TInput;
  outputSchema?: z.ZodType<TOutput>;
  handler: (
    args: TInput extends z.ZodTypeAny ? z.infer<TInput> : any,
  ) => Promise<TOutput>;
};

// --- Specialized Method Definitions for Automatic Schema Inference ---

type CreateMethod<T extends z.ZodObject<any>> = Omit<
  MethodDefinition<z.ZodObject<Omit<T['shape'], 'id' | 'createdAt' | 'updatedAt'>>, z.infer<T>>,
  'inputSchema' | 'outputSchema'
>;

type UpdateMethod<T extends z.ZodObject<any>> = Omit<
  MethodDefinition<
    z.ZodObject<any>,
    z.infer<T>
  >,
  'inputSchema' | 'outputSchema'
> & { handler: (args: z.infer<ReturnType<T['partial']>> & {id: string}) => Promise<z.infer<T>> };

type DeleteMethod<T extends z.ZodObject<any>> = Omit<
  MethodDefinition<z.ZodObject<{ id: z.ZodString }>, { success: boolean }>,
  'inputSchema' | 'outputSchema'
>;

type ListMethod<T extends z.ZodObject<any>> = Omit<
  MethodDefinition<z.ZodObject<{}>, z.infer<T>[]>,
  'inputSchema' | 'outputSchema'
>;

type GetMethod<T extends z.ZodObject<any>> = MethodDefinition<
  z.ZodObject<{ id: z.ZodString }>,
  z.infer<T> | undefined
>;

/**
 * The final, fully processed configuration for a resource.
 * This is the output of the `createResource` factory function.
 * @internal
 */
export interface ResourceConfig<T extends z.ZodObject<any, any, any>> {
  name: string;
  schema: T;
  uri_template: string;
  relations?: Partial<Record<keyof T['shape'], Relation>>;
  get?: (args: { id: string }) => Promise<z.infer<T> | undefined>;
  methods: Record<string, Method>;
}

/**
 * The user-facing blueprint for defining a resource and its methods.
 * This object is passed to the `createResource` factory.
 * @template T The main Zod schema for the resource.
 */
export interface ResourceBlueprint<T extends z.ZodObject<any, any, any>> {
  /** The singular, lowercase name of the resource (e.g., "note", "user"). */
  name: string;
  /** The Zod schema that defines the resource's data structure and validation rules. */
  schema: T;
  /**
   * A URI template for generating unique URIs for each resource instance.
   * Must include an `{id}` placeholder. Example: "notes/{id}".
   */
  uri_template: string;
  /**
   * Defines relationships to other resources. The keys must be fields in the schema.
   * This is used to enrich the exposed type schemas with `$ref` links.
   */
  relations?: Partial<Record<keyof T['shape'], Relation>>;

  /**
   * An object defining the tools (methods) for this resource.
   * The library provides default schemas and descriptions for standard
   * methods like `create`, `update`, `list`, and `delete`.
   */
  methods?: {
    get?: Partial<GetMethod<T>>;
    create?: Partial<CreateMethod<T>> & { inputSchema?: z.ZodObject<any> };
    update?: Partial<UpdateMethod<T>> & { inputSchema?: z.ZodObject<any> };
    delete?: Partial<DeleteMethod<T>>;
    list?: Partial<ListMethod<T>>;
    [key: string]: Partial<MethodDefinition<any, any>> | undefined;
  };
}

/** Configuration for the main MCP server. */
export interface MCPServerConfig {
  /** The name of the server, used in resource URIs. */
  name: string;
  /** The public-facing canonical URL of this server. Used for authentication (as audience) and in resource URIs. */
  serverUrl?: string;
  /**
   * An array of resource configurations.
   * This is now an array of the fully processed `ResourceConfig` objects.
   */
  resources: ResourceConfig<any>[];
  /**
   * If `true`, exposes JSON schemas for all resources.
   * If an array is provided, exposes schemas only for those resources.
   * This is crucial for enabling language models to understand the server's data model.
   */
  exposeTypes?: boolean | ResourceConfig<any>[];
  /** Optional configuration to enable OAuth 2.1 authentication. */
  auth?: AuthConfig;
}

// --- Type Definitions for Exposed Types ---
// These are internal types used for structuring the exposed schema information.

interface TypeField {
  name: string;
  type: string;
  description?: string;
  relation?: string;
}

interface TypeResource {
  name: string;
  description?: string;
  fields: TypeField[];
  related_tools: string[];
}

// --- Helper Functions ---

/**
 * A helper function that injects relationship metadata (`$ref` links) into a JSON schema.
 * This is used to connect related resource types in the exposed schemas.
 * @internal
 */
function applyRelationsToJsonSchema(
    jsonSchema: any,
    zodSchema: z.ZodObject<any>,
    relations: Partial<Record<string, Relation>> | undefined,
    serverName: string
) {
    if (!relations || !('properties' in jsonSchema)) {
        return jsonSchema;
    }

    const newProperties = { ...jsonSchema.properties };

    for (const fieldName in relations) {
        if (newProperties[fieldName]) {
            const relation = relations[fieldName];
            if (relation) {
                const relatedResourceName = relation.type;
                const ref = `type://${serverName}/${relatedResourceName}`;
                const fieldZodDef = zodSchema.shape[fieldName];

                if (fieldZodDef instanceof z.ZodArray) {
                    newProperties[fieldName].items = { $ref: ref };
                } else {
                    newProperties[fieldName] = { $ref: ref };
                }
            }
        }
    }

    return { ...jsonSchema, properties: newProperties };
}

// --- Core Implementation ---

/**
 * A factory function for creating a resource configuration object.
 * Provides type inference and helps ensure the configuration is valid.
 * @param config The resource configuration.
 * @returns The validated resource configuration object.
 */
export function createResource<T extends z.ZodObject<any, any, any>>(
  blueprint: ResourceBlueprint<T>
): ResourceConfig<T> {
  const { name, schema, methods: methodBlueprints } = blueprint;
  const processedMethods: Record<string, Method> = {};
  let getHandler: ((args: { id: string; }) => Promise<z.infer<T> | undefined>) | undefined;

  if (methodBlueprints) {
    // Handle the 'get' method as a special case first.
    if (methodBlueprints.get?.handler) {
      getHandler = methodBlueprints.get.handler as any;
      // Don't delete it - we'll process it as a regular method too
    }

    for (const methodName in methodBlueprints) {
      const methodDef = methodBlueprints[methodName as keyof typeof methodBlueprints] as any;
      if (!methodDef?.handler) continue;

      let { description, inputSchema, outputSchema, handler } = methodDef;
      let returnsResourceList = false;

      // Apply defaults for standard methods
      switch (methodName) {
        case 'get':
          description ??= `Get a ${name} by its ID.`;
          inputSchema ??= z.object({ id: z.string() });
          outputSchema ??= schema.optional();
          break;
        case 'create':
          description ??= `Create a new ${name}.`;
          inputSchema ??= schema.omit({ id: true, createdAt: true, updatedAt: true });
          outputSchema ??= schema;
          break;
        case 'update':
          description ??= `Update an existing ${name}.`;
          inputSchema ??= schema.partial().extend({ id: z.string() });
          outputSchema ??= schema;
          break;
        case 'delete':
          description ??= `Delete a ${name} by its ID.`;
          inputSchema ??= z.object({ id: z.string() });
          outputSchema ??= z.object({ success: z.boolean() });
          break;
        case 'list':
          description ??= `List all ${name}s.`;
          inputSchema ??= z.object({});
          outputSchema ??= z.array(schema);
          returnsResourceList = true;
          break;
        default: // Custom method or search
          if (!description) throw new Error(`Method '${methodName}' for resource '${name}' must have a description.`);
          if (!inputSchema) throw new Error(`Method '${methodName}' for resource '${name}' must have an inputSchema.`);
          outputSchema ??= z.any();
          if (methodName === 'search' || (outputSchema instanceof z.ZodArray && outputSchema.element === schema)) {
            returnsResourceList = true;
          }
          break;
      }
      
      processedMethods[methodName] = { description, inputSchema, outputSchema, handler, returnsResourceList };
    }
  }

  return {
    name: blueprint.name,
    schema: blueprint.schema,
    uri_template: blueprint.uri_template,
    relations: blueprint.relations,
    get: getHandler,
    methods: processedMethods,
  };
}

/**
 * Creates an Express app instance that serves a fully-functional MCP server.
 * @param config The server configuration object.
 * @returns An Express application instance.
 */
export function createMCPServer(config: MCPServerConfig): Express {
    const app = express();
    app.use(cors());
    app.use(express.json());

    if (config.auth) {
        app.get('/.well-known/oauth-protected-resource-metadata', (req, res) => {
            if (!config.auth) return res.status(500).send('Auth not configured');
            res.json({
                resource: config.serverUrl,
                authorization_servers: [config.auth.issuer],
            });
        });
    }

    const authMiddleware = config.auth
        ? createAuthMiddleware(config.auth, config.serverUrl ?? '')
        : (req: Request, res: Response, next: express.NextFunction) => next();

    const server = new McpServer({
        name: config.name,
        version: '1.0.0',
    }, {});

    // --- Validation ---
    // Before starting, validate that all declared relationships point to existing resources.
    // This prevents runtime errors and ensures schema integrity.
    const resourceNames = new Set(config.resources.map(r => r.name));
    for (const resource of config.resources) {
        const relations = resource.relations;
        if (relations) {
            for (const fieldName in relations) {
                if (!resource.schema.shape[fieldName]) {
                    throw new Error(`Configuration error in resource '${resource.name}': Relation field '${fieldName}' does not exist in the schema.`);
                }
                const relation = relations[fieldName as keyof typeof relations];
                if (!relation) {
                    continue;
                }
                const relatedResourceName = relation.type;
                if (!resourceNames.has(relatedResourceName)) {
                    throw new Error(`Configuration error in resource '${resource.name}': Related resource type '${relatedResourceName}' for field '${fieldName}' is not defined.`);
                }
            }
        }
    }

    // --- Type Exposure ---
    // If enabled, create special read-only resources that expose the JSON schema
    // of other resources. This allows clients (and AI models) to discover the data model.
    if (config.exposeTypes) {
        const resourcesToExpose = config.exposeTypes === true
            ? config.resources
            : config.exposeTypes;

        for (const resourceConfig of resourcesToExpose) {
            const { name: resourceName, schema, relations } = resourceConfig;

            const baseJsonSchema = zodToJsonSchema(schema, {
                $refStrategy: 'none'
            });

            const jsonSchemaWithRelations = applyRelationsToJsonSchema(baseJsonSchema, schema, relations, config.name);

            const related_tools = Object.keys(resourceConfig.methods)
                .map(handlerName => {
                    if (handlerName === 'list' || handlerName === 'search') return `${handlerName}_${resourceName}s`;
                    return `${handlerName}_${resourceName}`;
                });

            const resource_template_uri = resourceConfig.get ? `data://${config.name}/${resourceConfig.uri_template}` : undefined;

            const typeResource = {
                ...jsonSchemaWithRelations,
                name: resourceName,
                description: schema.description,
                related_tools,
                resource_template_uri,
            };

            // This is the read-only resource that serves the JSON schema.
            const uri = `type://${config.name}/${resourceName}`;
            server.resource(`${resourceName}`, uri, async (): Promise<ReadResourceResult> => {
                return {
                    contents: [{
                        uri,
                        mimeType: 'application/json',
                        text: JSON.stringify(typeResource, null, 2),
                    }],
                };
            });
        }
    }

    // --- Resource and Tool Registration ---
    // Loop through each user-defined resource and create the corresponding
    // MCP resources and tools.
    for (const resource of config.resources) {
        const { name, get, methods, uri_template, relations } = resource;

        /** Generates the canonical data URI for a resource instance. */
        const generateUri = (item: { id: string }): string => {
            return `data://${config.name}/${uri_template.replace('{id}', item.id)}`;
        };

        if (get) {
            const full_uri_template = `data://${config.name}/${uri_template}`;
            const template = new ResourceTemplate(full_uri_template, { list: undefined });
            server.resource(name, template, async (uri, { id }): Promise<ReadResourceResult> => {
                const item = await get({ id: id as string });
                if (!item) {
                    return { contents: [] };
                }
                return {
                    contents: [{
                        uri: uri.href,
                        mimeType: 'application/json',
                        text: JSON.stringify(item),
                    }],
                };
            });
        }
        
        // --- Workaround for schema generation with relations ---
        // The MCP SDK's `server.tool()` method builds the final JSON schema for the tool's input
        // internally. To inject our custom `$ref` properties for relations, we perform a trick:
        // 1. Create a temporary, isolated MCP server instance.
        // 2. Register a temporary tool on it with the desired input shape.
        // 3. This lets us access the generated `inputSchema` from the temporary tool.
        // 4. We then apply our relationship modifications to this schema.
        // 5. Finally, we create the *real* tool on our main server and then overwrite its
        //    (private) `inputSchema` property with our modified version.
        // This preserves the SDK's internal argument parsing while giving us the schema we need.

        for (const methodName in methods) {
            const method = methods[methodName];
            const { description, inputSchema, handler, returnsResourceList } = method;
            const toolName = (methodName === 'list' || methodName === 'search') ? `${methodName}_${name}s` : `${methodName}_${name}`;

            const tempServer = new McpServer({ name: 'temp', version: '1.0.0' }, {});
            const tempTool = tempServer.tool('temp', 'temp', inputSchema.shape, async () => ({ content: [] }));
            const inputSchemaWithRelations = applyRelationsToJsonSchema(tempTool.inputSchema, inputSchema, relations, config.name);

            const registeredTool = server.tool(toolName, description, inputSchema.shape, async (args: z.infer<typeof inputSchema>): Promise<CallToolResult> => {
                const result = await handler(args);
                
                // Validate the handler's output against the defined schema.
                const validatedResult = method.outputSchema.parse(result);

                // For methods that return a list of resources, add the canonical URI to each item.
                if (returnsResourceList && Array.isArray(validatedResult)) {
                    const resultsWithUris = validatedResult.map(item => ({
                        ...item,
                        uri: generateUri(item)
                    }));
                    return { content: [{ type: 'text', text: JSON.stringify(resultsWithUris) }] };
                }
                
                // For methods that return a single resource, add the canonical URI.
                if ((methodName === 'create' || methodName === 'update') && typeof validatedResult === 'object' && validatedResult !== null && 'id' in validatedResult) {
                     const resultWithUri = { ...validatedResult, uri: generateUri(validatedResult as { id: string }) };
                     return { content: [{ type: 'text', text: JSON.stringify(resultWithUri) }] };
                }

                return { content: [{ type: 'text', text: JSON.stringify(validatedResult) }] };
            });
            // Overwrite the schema with our modified version.
            (registeredTool as any).inputSchema = inputSchemaWithRelations;
        }
    }

    // --- Server Transport ---
    // Set up the Express endpoint to handle all incoming MCP requests.
    app.post('/', authMiddleware, async (req: Request, res: Response) => {
        // The transport handles the low-level details of the MCP over HTTP.
        const transport = new StreamableHTTPServerTransport({ sessionIdGenerator: undefined });
        await server.connect(transport);
        await transport.handleRequest(req, res, req.body);
        // Ensure the transport is cleaned up when the client connection closes.
        res.on('close', () => {
            transport.close();
            server.close();
        });
    });

    return app;
}
