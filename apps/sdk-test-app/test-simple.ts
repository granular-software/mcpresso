import { Agent, ComputerImage, OsLog } from "@joshu/sdk";
import type { AppsInstallConfig, AppConfig } from "@joshu/sdk";
import type {
	RelationshipChoiceReport,
	ActionChoiceReport,
	PermissionRequest,
	ActionApprovalRequest,
	Prerequisite,
	BackgroundJobReport,
} from "@joshu/os-types";
import crypto from "crypto";

const TEN_SECONDS = 10000;
const HALF_SECOND = 500;

console.log("RUN SIMPLE TEST WITH APP CONFIGURATION");

async function run() {
	try {
		// Define apps configuration to test the new feature
		const apps: AppsInstallConfig = {
			apps: [
				{
					name: "Task Manager",
					description: "An application to manage tasks and todos",
					icon: "✅",
					tabs: [
						{
							path: "app_tasks_application",
							label: "Tasks",
							description: "Task management interface",
							tab_name: "Tasks",
							components: [
								{
									type: "text_input",
									path: "app_task_search",
									label: "Search Tasks",
									description: "Search through tasks database"
								},
								{
									type: "instances_list",
									path: "app_tasks_list",
									label: "Task List",
									description: "List of all tasks with ability to create new ones",
									can_create: true,
									prototype: "task"
								}
							]
						}
					]
				},
				{
					name: "Customer Management",
					description: "An application to manage customer information",
					icon: "👥",
					tabs: [
						{
							path: "app_customers_application",
							label: "Customers",
							description: "Customer management interface",
							tab_name: "Customers",
							components: [
								{
									type: "instances_list",
									path: "app_customers_list",
									label: "Customer List",
									description: "List of all customers",
									can_create: true,
									prototype: "customer"
								}
							]
						}
					]
				}
			]
		};

		const computer = new ComputerImage({ 
			name: "SimpleTestComputer",
			apps: apps
		});

		try {
			console.log(`📦 Starting computer with ${apps.apps.length} apps configured:`);
			apps.apps.forEach((app: AppConfig) => {
				console.log(`   - ${app.icon} ${app.name}: ${app.description}`);
			});

			const session = await computer.start();

			console.log(`✅ Computer started with session: ${session}`);
			console.log(`📦 Apps should be installed automatically via install_apps message`);

			const agent = Agent.fromComputer(computer, {
				name: "SimpleTestAgent",
				description: "A simple test agent",
				instructions: "You are a helpful AI assistant. Help the user with their tasks and show them the available applications.",
			});

			console.log(`✅ Agent created: ${agent.getName()}`);

			await new Promise((resolve) => setTimeout(resolve, 1000));

			if (agent.isCreated()) {
				console.log(`✅ Agent created successfully! ID: ${agent.getId()?.slice(0, 8)}...`);
			} else {
				console.log(`⚠️  Agent creation timeout after ${TEN_SECONDS}ms`);
			}

			let updateCount = 0;
			const unsubscribeAgent = agent.subscribeToAgent((agentData) => {
				updateCount++;
			});

			// Subscribe to logs to see when new logs are synced
			let logCount = 0;
			const unsubscribeLogs = computer.subscribeToLogs((log: OsLog) => {
				logCount++;
				console.log(`📋 New log #${logCount}:`, {
					type: log.type,
					agent_id: log.agent_id,
					date: log.date,
					content: log.content,
				});
			});

			if (agent.isCreated()) {
				console.log("\n💬 Sending user query to test the installed apps...");
				try {
					await agent.give_task("Show me the task manager app and create a new task called 'Test Task'");
					console.log(`✅ User query sent successfully`);
				} catch (queryError: any) {
					console.log(`⚠️  User query failed: ${queryError.message}`);
				}
			}

			// Keep the test running for a bit to see the results
			console.log("\n⏳ Test running for 30 seconds to observe behavior...");
			await new Promise((resolve) => setTimeout(resolve, 30000));

			console.log("\n📊 Test Summary:");
			console.log(`   - Apps configured: ${apps.apps.length}`);
			console.log(`   - Log events captured: ${logCount}`);
			console.log(`   - Agent updates: ${updateCount}`);

			const finalDoc = computer.getState();
			if (finalDoc) {
				console.log(`   - Final windows count: ${finalDoc.windows.length}`);
				console.log(`   - Final agents count: ${finalDoc.agents.length}`);
			}

			/// HERE 

			/**
			 * DEMONSTRATION OF HUMAN-IN-THE-LOOP REPLIES
			 * The snippets below show how a *human client* (this script) can
			 *   1. watch the OsDocument for pending interactions generated by the agent
			 *   2. reply via the SDK helper methods we added earlier.
			 * For clarity we answer automatically with the first option / an approval,
			 * but in a real UI you would prompt the user and build the reply object
			 * from their decision.
			 */

			// Subscribe once – whenever we detect a *pending* interaction we respond
			computer.subscribe(async (doc) => {
				if (!doc) return;

				// 1. Relationship Choice
				const relChoice = doc.relationship_choices.find((c: RelationshipChoiceReport) => c.status === "pending");
				if (relChoice) {
					const reply: RelationshipChoiceReport = {
						...relChoice,
						status: "selected",
						selected_object_id: relChoice.candidates[0].object_id,
						resolved_at: new Date().toISOString(),
					};
					await computer.sendRelationshipChoice(reply);
				}

				// 2. Action Choice
				const aChoice = doc.action_choices.find((c: ActionChoiceReport) => c.status === "pending");
				if (aChoice) {
					const reply: ActionChoiceReport = {
						...aChoice,
						status: "selected",
						chosen_action_path: aChoice.options[0].action_path,
						resolved_at: new Date().toISOString(),
					};
					await computer.sendActionChoice(reply);
				}

				// 3. Permission Request – we approve everything for demo
				const perm = doc.permission_requests.find((p: PermissionRequest) => p.status === "pending");
				if (perm) {
					const reply: PermissionRequest = {
						...perm,
						status: "approved",
						approved_by: "user",
						resolved_at: new Date().toISOString(),
					};
					await computer.sendPermissionRequest(reply);
				}

				// 4. Action Approval – approve low-confidence action
				const appr = doc.action_approvals.find((a: ActionApprovalRequest) => a.status === "pending");
				if (appr) {
					const reply: ActionApprovalRequest = {
						...appr,
						status: "approved",
						approved_by: "user",
						resolved_at: new Date().toISOString(),
					};
					await computer.sendActionApproval(reply);
				}

				// 5. Follow-Up – answer with a canned response
				const follow = doc.prerequisites.find((f: Prerequisite) => f.status === "pending");
				if (follow) {
					const reply: Prerequisite = {
						...follow,
						status: "answered",
						answer_text: "Here is the information you requested!",
						answered_at: new Date().toISOString(),
					};
					await computer.sendPrerequisite(reply);
				}

				// 6. Background Job – fake progress until complete
				const job = doc.background_jobs.find((j: BackgroundJobReport) => j.status === "queued");
				if (job) {
					const running: BackgroundJobReport = { ...job, status: "running", progress_percentage: 50 };
					await computer.sendBackgroundJob(running);
					const done: BackgroundJobReport = {
						...running,
						status: "succeeded",
						progress_percentage: 100,
						finished_at: new Date().toISOString(),
					};
					await computer.sendBackgroundJob(done);
				}
			});

			// unsubscribeAgent();
			// unsubscribeLogs();
			// computer.stop();
			console.log("\n✅ Test completed successfully!");
			

		} catch (connectionError: any) {
			console.log(`⚠️  Connection failed: ${connectionError?.message || connectionError}`);
		}
	} catch (error) {
		console.error("\n💥 TEST FAILED:", error);
		process.exit(1);
	}
}

process.on("SIGINT", () => {
	console.log("\n\n👋 Shutting down test...");
	process.exit(0);
});

run().catch((error) => {
	console.error("💥 UNEXPECTED ERROR:", error);
	process.exit(1);
});
