directive @defer(if: Boolean, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT
directive @stream(if: Boolean, label: String, initialCount: Int = 0) on FIELD

type Model {
	path: String
	label: String
	description: String

	# is_root: Boolean
	# root: Model

	precursor: Model
	# head: String
	# tail: String

	at(submodel: String): Model
	# at_many(submodels: [String]): [Model!]!

	submodels: [Model!]!
	# find_submodels(class: String, max_depth: Int, follow_references: Boolean): [Model!]!

	# search_submodels(query: String): [ModelSearchResult!]!

	reference: Model
	reverse_references: [Model!]!

	# in_sets: [Model!]!

	prototypes: [Model!]!
	direct_prototypes: [Model!]!

	subclasses: [Model!]!
	direct_subclasses: [Model!]!

	superclasses: [Model!]!
	direct_superclasses: [Model!]!

	instances(string_filters: [StringFilter!], number_filters: [NumberFilter!], boolean_filters: [BooleanFilter!], date_filters: [DateFilter!], reference_filters: [ReferenceFilter!]): [Model!]!
	direct_instances(string_filters: [StringFilter!], number_filters: [NumberFilter!], boolean_filters: [BooleanFilter!], date_filters: [DateFilter!], reference_filters: [ReferenceFilter!]): [Model!]!

	unfilled_slots: [Model!]!

	if_has_class(name: String!): Model


	features(category: String): [Feature!]!

	feature_prototype_targets(category: String): [Model!]!
	feature_targets(category: String, path_root: String): [Model!]!

	string_value(path: String): String
	number_value(path: String): Float
	boolean_value(path: String): Boolean
	# string_array_value(path: String): [String!]!
	# number_array_value(path: String): [Float!]!
	# boolean_array_value(path: String): [Boolean!]!

	submodel_templates: [Model!]!

	as: Interface

	interfaces: [String!]!
	interface_constraints: [String!]!

	constraints: [Model!]!

	if_interface(interface: String!): Model

	filter_prototypes: [Feature!]!
	feature_prototypes(category: String): [Feature!]!
	filters: [Feature!]!

	# prototype_constraints: [Model!]!
	# superclass_constraints: [Model!]!

	# suggest_references: [Model!]!

	suggest_references(query: String): [ModelSearchResult!]!

	state(name: String!): StateMachineSnapshot
	states: [StateMachineSnapshot!]!
	state_machine(name: String!): StateMachine
}

type Feature {
	category: String

	abstraction_depth: Int


	model: Model
}

type ModelSearchResult {
	model: Model
	score: Float
}

type FeatureSearchResult {
	feature: Feature
	score: Float
}

enum ExtractionStatus {
	FOUND
	CREATED
	AMBIGUITY
}

enum FactKind {
	INSTANCE_OF
	SUBCLASS_OF
	REFERENCE
	HAS_PROPERTY
	MODEL
}

type Ambiguity {
	path: String
	options: [ModelSearchResult!]!
}

type Extraction {
	status: ExtractionStatus
	kind: FactKind
	label: String
	start: Model
	end: Model
	ambiguities: [Ambiguity!]!
}

type Explaination {
	kind: FactKind
	label: String
	start: Model
	end: Model
	ambiguities: [Ambiguity!]!
}

type Query {
	model(path: String): Model
	models(paths: [String!]!): [Model!]!

	prototypes: [Model!]!

	search_models(query: String): [ModelSearchResult!]!

	ask(query: String): [Explaination!]!
	explain(query: String): [Explaination!]!
	extract(text: String, models: [String!]!): [Extraction!]!
}

input ModelFilter {
	path: String
}

type ModelMutation {
	model: Model

	done: Boolean

	instantiate(path: String, label: String, prototype: String): ModelMutation
	extend(path: String, label: String, prototype: String): ModelMutation

	set_label(label: String): ModelMutation
	set_description(description: String): ModelMutation

	create_submodel(subpath: String, label: String, prototype: String): ModelMutation
	at(submodel: String): ModelMutation

	set_induction_threshold(minimal_support: Float, absolute_support: Int): Model
	suggest_induction(minimal_support: Float, absolute_support: Int): Model

	use_filter(feature: String!): ModelMutation

	remove_model: Boolean

	add_prototype(prototype: String!): ModelMutation
	add_superclass(superclass: String!): ModelMutation

	# create_submodel_template(template: String): ModelMutation
	# create_submodel_template_from_prototype(submodel: String): ModelMutation

	# # use_submodel_template(template: String!, subpath: String, label: String, as_reference: Boolean, as_constraint: Boolean, array: Boolean): ModelMutation

	create_submodel_from_prototype(prototype: String!, subpath: String, label: String, as_reference: Boolean, instantiate: Boolean, array: Boolean): ModelMutation

	set_reference(reference: String): ModelMutation
	remove_reference: ModelMutation

	set_string_value(value: String): ModelMutation
	set_number_value(value: Float): ModelMutation
	set_boolean_value(value: Boolean): ModelMutation
	# set_string_array_value(value: [String!]!): ModelMutation
	# set_number_array_value(value: [Float!]!): ModelMutation
	# set_boolean_array_value(value: [Boolean!]!): ModelMutation

	remove_value: ModelMutation

	use_feature(feature: String!): ModelMutation
	use_existing_feature(feature: String!, kind: String!): ModelMutation

	add_interface_constraint(interface: String!): ModelMutation
	remove_interface_constraint(interface: String!): ModelMutation

	add_prototype_constraint(prototype: String!, is_array: Boolean): ModelMutation
	remove_prototype_constraint(prototype: String!): ModelMutation

	as: MutationInterface

	# add_superclass_constraint(superclass: String!): ModelMutation
	# remove_superclass_constraint(superclass: String!): ModelMutation

	create_state_machine(name: String!, entry_state: String!): StateMachineMutation
	state(name: String!): StateMachineSnapshotMutation
	state_machine(name: String!): StateMachineMutation
}

type Mutation {
	create_model(path: String, label: String, prototype: String): ModelMutation
	at(path: String): ModelMutation

	_delete_everything: Boolean
}

type StateMachineMutation {
	foo: String
}

type StateMachineSnapshot {
	foo: String
}

type StateMachineSnapshotMutation {
	foo: String
}

type StateMachine {
	foo: String
}

type StateSnapshot {
	foo: String
}

type Interface {
	ok: Boolean
}

type MutationInterface {
	ok: Boolean
}

input StringFilter {
	at: String!
	not_null: Boolean
	contains: String
	not_contains: String
	starts_with: String
	ends_with: String
	equal_to: String
	length_greater_than: Int
	length_less_than: Int
}

input NumberFilter {
	at: String!
	not_null: Boolean
	greater_than: Float
	less_than: Float
	equal_to: Float
}

input BooleanFilter {
	at: String!
	null: Boolean
	not_null: Boolean
	equal_to: Boolean
}

input DateFilter {
	at: String!

	not_null: Boolean
	null: Boolean
	before_date: Float
	after_date: Float
	older_than_seconds: Int
	newer_than_seconds: Int
}

input ReferenceFilter {
	at: String!

	null: Boolean
	not_null: Boolean
	is: String
}

# type StateMachine {
# 	model: Model

# 	states: [State!]!
# 	entry_state: State
# 	finale_states: [State!]!
# }

# type StateMachineMutation {
# 	state_machine: StateMachine

# 	add_state(name: String, isEntry: Boolean, isFinale: Boolean): StateMachineMutation
# }

# type State {
# 	model: Model

# 	finale: Boolean
# 	entry: Boolean

# 	transitions: [Transition!]!
# }

# type Transition {
# 	model: Model
# 	active_transition: Boolean
# 	passive_transition: Boolean

# 	from: State
# 	to: State
# }

# type Model {

# 	state(name: String): StateSnapshot
# 	state_machine(name: String): StateMachine
# }

# type ModelMutation {

# 	state(name: String): StateSnapshotMutation
# 	create_state_machine(name: String, entry_state_name: String!): StateMachineMutation

# }

# type State {
# 	state_machine: StateMachine
# }

# type StateMutation {

# }

# type Transition {

# }

# type StateMachine {
# 	entry_state: State
# 	states: [State!]!
# 	finale_states: [State!]!
# }

# type StateMachineMutation {
# 	get: StateMachine

# 	add_state(name: String, isFinale: Boolean): StateMachineMutation
# }

# type StateSnapshot {
# 	current: State

# 	previous: State
# 	history: [State!]!
# }

# type StateSnapshotMutation {
# 	get: StateSnapshot

# 	run_transition(transition: String): StateSnapshotMutation

# }
