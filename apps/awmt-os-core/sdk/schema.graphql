directive @defer(if: Boolean, label: String) on FRAGMENT_SPREAD | INLINE_FRAGMENT

directive @stream(if: Boolean, label: String, initialCount: Int = 0) on FIELD

"""
Exposes a URL that specifies the behavior of this scalar.
"""
directive @specifiedBy(
  """
  The URL that specifies the behavior of this scalar.
  """
  url: String!
) on SCALAR

"""
Indicates exactly one field must be supplied and this field must not be `null`.
"""
directive @oneOf on INPUT_OBJECT

type Ambiguity {
  path: String
  options: [ModelSearchResult!]!
}

input BooleanFilter {
  at: String!
  null: Boolean
  not_null: Boolean
  equal_to: Boolean
}

type DataTable {
  _todo: Boolean
}

type DataTableMutation {
  _todo_mutation(value: Boolean!): Boolean
}

type Date {
  ms_timestamp: Float
  s_timestamp: Float
  get(format: String!): String
}

input DateFilter {
  at: String!
  not_null: Boolean
  null: Boolean
  before_date: Float
  after_date: Float
  older_than_seconds: Int
  newer_than_seconds: Int
}

type DateMutation {
  set_now: Date
  set_timestamp(timestamp: Float!): Date
  set(format: String!, date: String!): Date
  add_seconds(seconds: Int!): Date
  add_minutes(minutes: Int!): Date
  add_hours(hours: Int!): Date
  add_days(days: Int!): Date
  add_months(months: Int!): Date
  add_years(years: Int!): Date
}

type Explaination {
  kind: FactKind
  label: String
  start: Model
  end: Model
  ambiguities: [Ambiguity!]!
}

type Extraction {
  status: ExtractionStatus
  kind: FactKind
  label: String
  start: Model
  end: Model
  ambiguities: [Ambiguity!]!
}

enum ExtractionStatus {
  FOUND
  CREATED
  AMBIGUITY
}

enum FactKind {
  INSTANCE_OF
  SUBCLASS_OF
  REFERENCE
  HAS_PROPERTY
  MODEL
}

type Feature {
  category: String
  abstraction_depth: Int
  model: Model
}

type FeatureSearchResult {
  feature: Feature
  score: Float
}

type Interface {
  ok: Boolean
  Date: Date
  Set: Set
  DataTable: DataTable
}

type Model {
  path: String
  label: String
  description: String
  precursor: Model
  at(submodel: String): Model
  submodels: [Model!]!
  reference: Model
  reverse_references: [Model!]!
  prototypes: [Model!]!
  direct_prototypes: [Model!]!
  subclasses: [Model!]!
  direct_subclasses: [Model!]!
  superclasses: [Model!]!
  direct_superclasses: [Model!]!
  instances(
    string_filters: [StringFilter!]
    number_filters: [NumberFilter!]
    boolean_filters: [BooleanFilter!]
    date_filters: [DateFilter!]
    reference_filters: [ReferenceFilter!]
  ): [Model!]!
  direct_instances(
    string_filters: [StringFilter!]
    number_filters: [NumberFilter!]
    boolean_filters: [BooleanFilter!]
    date_filters: [DateFilter!]
    reference_filters: [ReferenceFilter!]
  ): [Model!]!
  unfilled_slots: [Model!]!
  if_has_class(name: String!): Model
  features(category: String): [Feature!]!
  feature_prototype_targets(category: String): [Model!]!
  feature_targets(category: String, path_root: String): [Model!]!
  string_value(path: String): String
  number_value(path: String): Float
  boolean_value(path: String): Boolean
  submodel_templates: [Model!]!
  as: Interface
  interfaces: [String!]!
  interface_constraints: [String!]!
  constraints: [Model!]!
  if_interface(interface: String!): Model
  filter_prototypes: [Feature!]!
  feature_prototypes(category: String): [Feature!]!
  filters: [Feature!]!
  suggest_references(query: String): [ModelSearchResult!]!
  state(name: String!): StateMachineSnapshot
  states: [StateMachineSnapshot!]!
  state_machine(name: String!): StateMachine
}

input ModelFilter {
  path: String
}

type ModelMutation {
  model: Model
  done: Boolean
  instantiate(path: String, label: String, prototype: String): ModelMutation
  extend(path: String, label: String, prototype: String): ModelMutation
  set_label(label: String): ModelMutation
  set_description(description: String): ModelMutation
  create_submodel(subpath: String, label: String, prototype: String): ModelMutation
  at(submodel: String): ModelMutation
  set_induction_threshold(minimal_support: Float, absolute_support: Int): Model
  suggest_induction(minimal_support: Float, absolute_support: Int): Model
  use_filter(feature: String!): ModelMutation
  remove_model: Boolean
  add_prototype(prototype: String!): ModelMutation
  add_superclass(superclass: String!): ModelMutation
  create_submodel_from_prototype(
    prototype: String!
    subpath: String
    label: String
    as_reference: Boolean
    instantiate: Boolean
    array: Boolean
  ): ModelMutation
  set_reference(reference: String): ModelMutation
  remove_reference: ModelMutation
  set_string_value(value: String): ModelMutation
  set_number_value(value: Float): ModelMutation
  set_boolean_value(value: Boolean): ModelMutation
  remove_value: ModelMutation
  use_feature(feature: String!): ModelMutation
  use_existing_feature(feature: String!, kind: String!): ModelMutation
  add_interface_constraint(interface: String!): ModelMutation
  remove_interface_constraint(interface: String!): ModelMutation
  add_prototype_constraint(prototype: String!, is_array: Boolean): ModelMutation
  remove_prototype_constraint(prototype: String!): ModelMutation
  as: MutationInterface
  create_state_machine(name: String!, entry_state: String!): StateMachineMutation
  state(name: String!): StateMachineSnapshotMutation
  state_machine(name: String!): StateMachineMutation
}

type ModelSearchResult {
  model: Model
  score: Float
}

type Mutation {
  create_model(path: String, label: String, prototype: String): ModelMutation
  at(path: String): ModelMutation
  _delete_everything: Boolean
}

type MutationInterface {
  ok: Boolean
  DateMutation: DateMutation
  SetMutation: SetMutation
  DataTableMutation: DataTableMutation
}

input NumberFilter {
  at: String!
  not_null: Boolean
  greater_than: Float
  less_than: Float
  equal_to: Float
}

type Query {
  model(path: String): Model
  models(paths: [String!]!): [Model!]!
  prototypes: [Model!]!
  search_models(query: String): [ModelSearchResult!]!
  ask(query: String): [Explaination!]!
  explain(query: String): [Explaination!]!
  extract(text: String, models: [String!]!): [Extraction!]!
}

input ReferenceFilter {
  at: String!
  null: Boolean
  not_null: Boolean
  is: String
}

type Set {
  size: Int!
  get_n(first_n: Int): [Model]
}

type SetMutation {
  create_element: Model!
}

type StateMachine {
  foo: String
}

type StateMachineMutation {
  foo: String
}

type StateMachineSnapshot {
  foo: String
}

type StateMachineSnapshotMutation {
  foo: String
}

type StateSnapshot {
  foo: String
}

input StringFilter {
  at: String!
  not_null: Boolean
  contains: String
  not_contains: String
  starts_with: String
  ends_with: String
  equal_to: String
  length_greater_than: Int
  length_less_than: Int
}
